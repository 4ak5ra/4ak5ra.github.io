---
title: cpp底层基础知识
tags: 
- pwn
- cpp_pwn
---


## 作用域
作用域（Scope）用于组织代码和避免命名冲突，也就是说你可以用定义两个不同类型但相同名字的变量(在不同作用域)   

      
1. 全局作用域作用域 

全局作用域就是宏，数据存在.bss段或者.data段之类的地方

2. 名字空间作用域(命名空间)     

定义一个名字作为标识符，通过这个标识符(名字)::变量名的方式访问里面的变量，C++标准库中的所有标识符都定义在std命名空间中  

这也就是为什么用cout函数的时候要```std::cout```
3. 局部作用域:  

局部变量，存在stack上的数据
4. 类作用域（class scope）:     


一个类的结构范围就是一个类作用域，被定义在类里面的数据被称为成员      


对于类函数来说，编译器会把 `类名称,函数名称,参数列表` 放入哈希函数转化为一个哈希值，并用这个哈希值来当做函数的名称
5. 语句作用域:  


在for while if的语句里也可以定义数据，这里就是语句作用域

## this指针
指向当前对象的指针，类型为指向类类型的指针（例如，对于 Base 类，this 的类型是 Base*）
### 底层
源码
```c++
#include<iostream>
#include<string.h> 
using namespace std;

class Base{
public:
    void fun(){                /* 成员函数的代码是存储在程序的代码段中，而不是存储在类的实例中。每个类的成员函数在内存中只有一份实现 */
        cout<<name<<endl;
    }
    char name[10];
};
class A : public Base{
public:
    void foo(){
        strcpy(this->name,"A");
        this->fun(); // 相当于fun
    }
};
class B : public Base{
public:
    void foo(){
        strcpy(this->name,"B");
        this->fun();
    }
};
int main(void){
    A *a = new A();         /* 调用类函数时，会将其 new 出来的堆内存当做第一个参数传入（相当于传入了该对象的数据结构体） */
    B *b = new B();
    a->foo();              
    b->foo();          
}
```
ida
```c
__int64 __fastcall B::foo(B *this)  /* foo()这个成员函数 */
{
  *(_WORD *)this = 66;
  return Base::fun(this);
}

__int64 __fastcall A::foo(A *this)
{
  *(_WORD *)this = 65;
  return Base::fun(this);
}

__int64 __fastcall Base::fun(Base *this)
{
  std::ostream *v1; // rax

  v1 = (std::ostream *)std::operator<<<std::char_traits<char>>(refptr__ZSt4cout, (char *)this);
  return refptr__ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_(v1);
}

int __cdecl main(int argc, const char **argv, const char **envp)
{
  __int64 v3; // rax
  __int64 v4; // rax
  B *v6; // [rsp+20h] [rbp-10h]
  A *v7; // [rsp+28h] [rbp-8h]

  _main();
  v3 = operator new(0xAui64); 
  *(_QWORD *)v3 = 0i64;        
  *(_WORD *)(v3 + 8) = 0;      
  v7 = (A *)v3;
  v4 = operator new(0xAui64);    /* 返回的应该是一个指向当前对象实例的this指针 */ 
  *(_QWORD *)v4 = 0i64;           /* 这两行是编译器的优化，帮我们初始化了分配name段的内存 */
  *(_WORD *)(v4 + 8) = 0;
  v6 = (B *)v4;             
  A::foo(v7);               /* 编译器会在调用时自动将对象的地址（即 this 指针）传递给该函数。这使得函数可以访问该对象的成员变量和其他成员函数 */
  B::foo(v6);                 /* 这也就是为什么我们什么在代码里什么都没传但ida的里面却有参数 */
  return 0;
}
```

## 重载
### 函数重载
>允许在同一个作用域中定义多个同名的函数，但是这些函数必须有不同的参数列表(参数类型，顺序，个数)。
编译器在函数调用时根据参数的类型和数量来决定调用哪个具体的函数版本，这一过程称为```静态绑定```(留个印象)
   
----

```c++
#include <iostream>
using namespace std;
class Example {
public:
    int add(int a, int b) {
        return a + b;
    }
    double add(double a, double b) {
        return a + b;
    }
    int add(int a, int b, int c) {
        return a + b + c;
    }
};
int main() {
    Example obj;
    cout << obj.add(2, 3) << endl;      // 输出 5
    cout << obj.add(2.5, 3.5) << endl;  // 输出 6.0
    cout << obj.add(1, 2, 3) << endl;    // 输出 6
    //用户只需记住一个函数名，而不必为每个参数组合记住不同的函数名
    return 0;
}
```

### 运算符重载

>本质上就是函数重载，但语法有点不一样
定义一个函数，并告诉C++编译器，当遇到该运算符时就调用此函数来执行运算符功能。这个函数叫做运算符重载函数（常为类的成员函数）

#### 例子
```c++
(返回值类型) (类名)(::operator)(重载的运算符)(参数表)
   {
    // 函数体
   }

   //operator是关键字，它与重载的运算符一起构成函数名
```

```c++
#include <iostream>
using namespace std;

class Point{
public:
//访问修饰符，表示下面的成员（构造函数和友元函数）可以被类的外部访问
    Point(){};
    //Point 类的默认构造函数，允许创建 Point 对象而不传入参数。这里的 {} 表示构造函数的空实现
    Point (int x, int y): x(x),y(y) {};
    //参数的构造函数，使用初始化列表（: x(x), y(y)）将传入的参数 x 和 y 初始化到类的私有成员变量 x 和 y
    friend ostream &operator<<(ostream &out , const Point &a);  
    //声明友元函数，可以访问 Point 类的私有成员变量。ostream 是输出流的类，cout是其中的对象 ，<< 是其中的方法，a 是 Point 类的常量引用
    
private:
    int x,y;
};

//<< 运算符重载的函数实现 ，ostream是输入输出流的类
ostream &operator<<(ostream &out , const Point &a){
    out << "<Point>( " << a.x << ", " << a.y << ")";
    return out;
}

int main() {

    cout << c<< endl;    //直接输出类会报错，需要上面的 << 运算符重载
}
```

## 容器声明
### 关联容器
1. unordered_map
```c++
#include <iostream>
#include <unordered_map>
int main() {
    // 声明一个 unordered_map,名字为test
    //这是 C++ 标准库中的一个关联容器，定义在 <unordered_map> 头文件中
    std::unordered_map<int, long> test;
    //<int, long> 指定了容器中键（key）和值（value）的类型
    // 插入元素
    test[1] = 100000L;
   // 访问元素
    std::cout << "Key: 1, Value: " << test[1] << std::endl;
    return 0;
}
```
### 序列容器

1. vector
```c++
#include <iostream>
#include <vector>
int main() {
    std::vector<int> myVector;

    // 添加元素
    myVector.push_back(1);
    // 访问元素
    for (int i = 0; i < myVector.size(); ++i) {
        std::cout << myVector[i] << " ";
    }
    std::cout << std::endl;

    // 删除元素
    myVector.pop_back(); // 删除最后一个元素

    // 打印剩余元素
    for (int value : myVector) {
        std::cout << value << " ";
    }
    std::cout << std::endl;
    return 0;
}
```

## 迭代器
迭代器是一种检查容器(可以理解为类，里面有数据结构和配套的算法)内元素并遍历元素的`数据类型`，通常用于对C++中各种容器内元素的访问，为了方便对不同的容器有相同的访问方法而设计出来，不同的容器有不同的迭代器，可以将迭代器理解为指针

begin()就是指向容器第一个元素的迭代器，end()是指向容器最后一个元素的下一个位置的迭代器

```c++
void text()
{
	vector<int> vtr;
	//初始化容器
	for (int i = 0; i < 10; ++i)
	{
		vtr.push_back(i);
	}
	//利用迭代器遍历容器
	cout << "方式1：";
	for (vector<int>::iterator it = vtr.begin(); it != vtr.end(); ++it)
	{
		cout << *it << " ";
	}
}
```

